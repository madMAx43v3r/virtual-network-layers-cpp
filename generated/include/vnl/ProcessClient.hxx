
#ifndef INCLUDE_VNI_GENERATED_vnl_Process_CLIENT_HXX_
#define INCLUDE_VNI_GENERATED_vnl_Process_CLIENT_HXX_

// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/Announce.hxx>
#include <vnl/Array.h>
#include <vnl/Exit.hxx>
#include <vnl/Hash32.h>
#include <vnl/Heartbeat.hxx>
#include <vnl/Instance.hxx>
#include <vnl/LogMsg.hxx>
#include <vnl/Map.h>
#include <vnl/Shutdown.hxx>
#include <vnl/String.h>
#include <vnl/info/TopicInfoList.hxx>
#include <vnl/info/Type.hxx>

#include <vnl/ObjectClient.hxx>


namespace vnl {

class ProcessClient : public vnl::ObjectClient {
public:
	class Writer : public vnl::ObjectClient::Writer {
	public:
		Writer(vnl::io::TypeOutput& _out, bool _top_level = false) 
			:	vnl::ObjectClient::Writer(_out, false),
				_out(_out), _top_level(_top_level)
		{
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_BEGIN);
				_out.putHash(0x46f438);
			}
		}
		~Writer() {
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_END);
			}
		}
		void pause_log() {
			_out.putEntry(VNL_IO_CALL, 0);
			_out.putHash(0xbb55be0c);
		}
		void get_type_info() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xf73490b7);
		}
		void shutdown() {
			_out.putEntry(VNL_IO_CALL, 0);
			_out.putHash(0x87e2d7f);
		}
		void get_class_names() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xaa2ef6d9);
		}
		void set_log_filter(const vnl::String& filter) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x70d1a0f8);
			vnl::write(_out, filter);
		}
		void resume_log() {
			_out.putEntry(VNL_IO_CALL, 0);
			_out.putHash(0xaf20300);
		}
		void get_objects() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xbced8d0d);
		}
		void get_topic_info() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xd50fc0dd);
		}
		void set_name(const vnl::String& _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x539b7130);
			vnl::write(_out, _value);
		}
		void set_watchdog_interval(int32_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x498bb8f5);
			vnl::write(_out, _value);
		}
		void set_update_interval(int32_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xd04a8e2b);
			vnl::write(_out, _value);
		}
		void set_stats_interval(int32_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x3a0f0e4b);
			vnl::write(_out, _value);
		}
		void set_do_print_stats(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x36eb5937);
			vnl::write(_out, _value);
		}
		void get_name() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x539b7130);
		}
		void get_watchdog_interval() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x498bb8f5);
		}
		void get_update_interval() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xd04a8e2b);
		}
		void get_stats_interval() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x3a0f0e4b);
		}
		void get_do_print_stats() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x36eb5937);
		}
	protected:
		vnl::io::TypeOutput& _out;
		bool _top_level;
	};
	
	ProcessClient() {}
	
	ProcessClient(const ProcessClient& other) {
		vnl::Client::set_address(other.vnl::Client::get_address());
	}
	
	ProcessClient(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
	}
	
	ProcessClient& operator=(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
		return *this;
	}
	
	void pause_log() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.pause_log();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::Map<vnl::Hash32, vnl::info::Type > get_type_info() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_type_info();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::Map<vnl::Hash32, vnl::info::Type > _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	void shutdown() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.shutdown();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::Array<vnl::String > get_class_names() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_class_names();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::Array<vnl::String > _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	void set_log_filter(const vnl::String& filter) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_log_filter(filter);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void resume_log() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.resume_log();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::Array<vnl::Instance > get_objects() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_objects();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::Array<vnl::Instance > _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	vnl::info::TopicInfoList get_topic_info() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_topic_info();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::info::TopicInfoList _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	void set_name(const vnl::String& name) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_name(name);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_watchdog_interval(int32_t watchdog_interval) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_watchdog_interval(watchdog_interval);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_update_interval(int32_t update_interval) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_update_interval(update_interval);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_stats_interval(int32_t stats_interval) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_stats_interval(stats_interval);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_do_print_stats(bool do_print_stats) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_do_print_stats(do_print_stats);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::String get_name() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_name();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::String _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int32_t get_watchdog_interval() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_watchdog_interval();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int32_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int32_t get_update_interval() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_update_interval();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int32_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int32_t get_stats_interval() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_stats_interval();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int32_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_do_print_stats() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_do_print_stats();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
};


} // namespace

#endif // INCLUDE_VNI_GENERATED_vnl_Process_CLIENT_HXX_
