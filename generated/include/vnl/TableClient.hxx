
#ifndef INCLUDE_VNI_GENERATED_vnl_Table_CLIENT_HXX_
#define INCLUDE_VNI_GENERATED_vnl_Table_CLIENT_HXX_

// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/Array.h>
#include <vnl/Hash32.h>
#include <vnl/Hash64.h>
#include <vnl/Var.h>

#include <vnl/DatabaseClient.hxx>


namespace vnl {

template<class T>
class TableClient : public vnl::DatabaseClient {
public:
	class Writer : public vnl::DatabaseClient::Writer {
	public:
		Writer(vnl::io::TypeOutput& _out, bool _top_level = false) 
			:	vnl::DatabaseClient::Writer(_out, false),
				_out(_out), _top_level(_top_level)
		{
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_BEGIN);
				_out.putHash(0xbd71f457);
			}
		}
		~Writer() {
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_END);
			}
		}
		void update(const vnl::Hash64& id, const vnl::Hash32& field_name, const vnl::Var& value) {
			_out.putEntry(VNL_IO_CALL, 3);
			_out.putHash(0x62d971d5);
			vnl::write(_out, id);
			vnl::write(_out, field_name);
			vnl::write(_out, value);
		}
		void insert(const T& row) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xaeb0fe60);
			vnl::write(_out, row);
		}
		void get(const vnl::Hash64& id) {
			_out.putEntry(VNL_IO_CONST_CALL, 1);
			_out.putHash(0x1b0fad1f);
			vnl::write(_out, id);
		}
		void get_all(const vnl::Array<vnl::Hash64 >& ids) {
			_out.putEntry(VNL_IO_CONST_CALL, 1);
			_out.putHash(0x6726988c);
			vnl::write(_out, ids);
		}
		void remove(const vnl::Hash64& id) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x299f3f53);
			vnl::write(_out, id);
		}
	protected:
		vnl::io::TypeOutput& _out;
		bool _top_level;
	};
	
	TableClient() {}
	
	TableClient(const TableClient& other) {
		vnl::Client::set_address(other.vnl::Client::get_address());
	}
	
	TableClient(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
	}
	
	TableClient& operator=(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
		return *this;
	}
	
	void update(const vnl::Hash64& id, const vnl::Hash32& field_name, const vnl::Var& value) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.update(id, field_name, value);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void insert(const T& row) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.insert(row);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	T get(const vnl::Hash64& id) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get(id);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		T _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	vnl::Array<T > get_all(const vnl::Array<vnl::Hash64 >& ids) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_all(ids);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::Array<T > _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	void remove(const vnl::Hash64& id) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.remove(id);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
};


} // namespace

#endif // INCLUDE_VNI_GENERATED_vnl_Table_CLIENT_HXX_
