
#ifndef INCLUDE_VNI_GENERATED_vnl_Database_CLIENT_HXX_
#define INCLUDE_VNI_GENERATED_vnl_Database_CLIENT_HXX_

// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/String.h>

#include <vnl/ObjectClient.hxx>


namespace vnl {

class DatabaseClient : public vnl::ObjectClient {
public:
	class Writer : public vnl::ObjectClient::Writer {
	public:
		Writer(vnl::io::TypeOutput& _out, bool _top_level = false) 
			:	vnl::ObjectClient::Writer(_out, false),
				_out(_out), _top_level(_top_level)
		{
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_BEGIN);
				_out.putHash(0x1a20923);
			}
		}
		~Writer() {
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_END);
			}
		}
		void set_filename(const vnl::String& _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xb60d3446);
			vnl::write(_out, _value);
		}
		void set_interval(int32_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xd129c896);
			vnl::write(_out, _value);
		}
		void set_readonly(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x972da0ea);
			vnl::write(_out, _value);
		}
		void set_temporary(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xcfa52de4);
			vnl::write(_out, _value);
		}
		void set_ignore_errors(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x2d7512a8);
			vnl::write(_out, _value);
		}
		void set_truncate(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x1725750d);
			vnl::write(_out, _value);
		}
		void get_filename() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xb60d3446);
		}
		void get_interval() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xd129c896);
		}
		void get_readonly() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x972da0ea);
		}
		void get_temporary() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xcfa52de4);
		}
		void get_ignore_errors() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x2d7512a8);
		}
		void get_truncate() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x1725750d);
		}
	protected:
		vnl::io::TypeOutput& _out;
		bool _top_level;
	};
	
	DatabaseClient() {}
	
	DatabaseClient(const DatabaseClient& other) {
		vnl::Client::set_address(other.vnl::Client::get_address());
	}
	
	DatabaseClient(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
	}
	
	DatabaseClient& operator=(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
		return *this;
	}
	
	void set_filename(const vnl::String& filename) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_filename(filename);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_interval(int32_t interval) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_interval(interval);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_readonly(bool readonly) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_readonly(readonly);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_temporary(bool temporary) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_temporary(temporary);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_ignore_errors(bool ignore_errors) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_ignore_errors(ignore_errors);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_truncate(bool truncate) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_truncate(truncate);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::String get_filename() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_filename();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::String _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int32_t get_interval() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_interval();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int32_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_readonly() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_readonly();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_temporary() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_temporary();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_ignore_errors() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_ignore_errors();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_truncate() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_truncate();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
};


} // namespace

#endif // INCLUDE_VNI_GENERATED_vnl_Database_CLIENT_HXX_
