
#ifndef INCLUDE_VNI_GENERATED_vnl_StorageBase_HXX_
#define INCLUDE_VNI_GENERATED_vnl_StorageBase_HXX_

// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/Array.h>
#include <vnl/Entry.hxx>
#include <vnl/Hash64.h>
#include <vnl/Interface.h>
#include <vnl/Pointer.h>

#include <vnl/Type.hxx>


namespace vnl {

class StorageBase : public vnl::Interface {
public:
	static const uint32_t VNI_HASH = 0xc1f517f6;
	static const uint32_t NUM_FIELDS = 0;
	
	typedef vnl::Interface Super;
	
	
	
	StorageBase();
	
	virtual uint32_t get_vni_hash() const { return VNI_HASH; }
	virtual const char* get_type_name() const { return "vnl.Storage"; }
	
	virtual int get_num_fields() const { return NUM_FIELDS; }
	virtual int get_field_index(vnl::Hash32 _hash) const;
	virtual const char* get_field_name(int _index) const;
	virtual void get_field(int _index, vnl::String& _str) const;
	virtual void set_field(int _index, const vnl::String& _str);
	virtual void get_field(int _index, vnl::io::TypeOutput& _out) const;
	virtual void set_field(int _index, vnl::io::TypeInput& _in);
	virtual void get_field(int _index, vnl::Var& _var) const;
	virtual void set_field(int _index, const vnl::Var& _var);
	
protected:
	virtual void delete_entry(const vnl::Hash64& key) = 0;
	virtual void put_entry(const vnl::Pointer<vnl::Entry >& value) = 0;
	virtual vnl::Array<vnl::Pointer<vnl::Entry > > get_entries(const vnl::Array<vnl::Hash64 >& keys) const = 0;
	virtual vnl::Pointer<vnl::Entry > get_entry(const vnl::Hash64& key) const = 0;
	
	virtual bool vni_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args);
	virtual bool vni_const_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args, vnl::io::TypeOutput& _out);
	
	template<class W>
	void write_fields(W& _writer) const {
	}
	
};

} // namespace

#endif // INCLUDE_VNI_GENERATED_vnl_StorageBase_HXX_
