
#ifndef INCLUDE_VNI_GENERATED_vnl_TcpUplink_CLIENT_HXX_
#define INCLUDE_VNI_GENERATED_vnl_TcpUplink_CLIENT_HXX_

// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/Address.h>
#include <vnl/String.h>
#include <vnl/Topic.hxx>
#include <vnl/info/RemoteInfo.hxx>

#include <vnl/ObjectClient.hxx>


namespace vnl {

class TcpUplinkClient : public vnl::ObjectClient {
public:
	class Writer : public vnl::ObjectClient::Writer {
	public:
		Writer(vnl::io::TypeOutput& _out, bool _top_level = false) 
			:	vnl::ObjectClient::Writer(_out, false),
				_out(_out), _top_level(_top_level)
		{
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_BEGIN);
				_out.putHash(0xb681b3d8);
			}
		}
		~Writer() {
			if(_top_level) {
				_out.putEntry(VNL_IO_INTERFACE, VNL_IO_END);
			}
		}
		void publish(const vnl::Address& addr) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x983c173d);
			vnl::write(_out, addr);
		}
		void unsubscribe(const vnl::String& domain, const vnl::String& topic) {
			_out.putEntry(VNL_IO_CALL, 2);
			_out.putHash(0xed7dfb37);
			vnl::write(_out, domain);
			vnl::write(_out, topic);
		}
		void subscribe(const vnl::String& domain, const vnl::String& topic) {
			_out.putEntry(VNL_IO_CALL, 2);
			_out.putHash(0x3bb5d48f);
			vnl::write(_out, domain);
			vnl::write(_out, topic);
		}
		void reset() {
			_out.putEntry(VNL_IO_CALL, 0);
			_out.putHash(0xbd19b5cb);
		}
		void publish(const vnl::String& domain, const vnl::String& topic) {
			_out.putEntry(VNL_IO_CALL, 2);
			_out.putHash(0x7fbbe878);
			vnl::write(_out, domain);
			vnl::write(_out, topic);
		}
		void get_remote_info() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x6ccccd5b);
		}
		void unpublish(const vnl::String& domain, const vnl::String& topic) {
			_out.putEntry(VNL_IO_CALL, 2);
			_out.putHash(0xc7428d8c);
			vnl::write(_out, domain);
			vnl::write(_out, topic);
		}
		void set_error_interval(int32_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x55f7671e);
			vnl::write(_out, _value);
		}
		void set_are_connected(bool _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x1f5839d4);
			vnl::write(_out, _value);
		}
		void set_num_read(int64_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x7d63bf0a);
			vnl::write(_out, _value);
		}
		void set_num_write(int64_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0xce66f455);
			vnl::write(_out, _value);
		}
		void set_num_flush(int64_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x60ca0d4f);
			vnl::write(_out, _value);
		}
		void set_num_bytes_read(int64_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x668ecf71);
			vnl::write(_out, _value);
		}
		void set_num_bytes_write(int64_t _value) {
			_out.putEntry(VNL_IO_CALL, 1);
			_out.putHash(0x9112770d);
			vnl::write(_out, _value);
		}
		void get_error_interval() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x55f7671e);
		}
		void get_are_connected() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x1f5839d4);
		}
		void get_num_read() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x7d63bf0a);
		}
		void get_num_write() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0xce66f455);
		}
		void get_num_flush() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x60ca0d4f);
		}
		void get_num_bytes_read() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x668ecf71);
		}
		void get_num_bytes_write() {
			_out.putEntry(VNL_IO_CONST_CALL, 0);
			_out.putHash(0x9112770d);
		}
	protected:
		vnl::io::TypeOutput& _out;
		bool _top_level;
	};
	
	TcpUplinkClient() {}
	
	TcpUplinkClient(const TcpUplinkClient& other) {
		vnl::Client::set_address(other.vnl::Client::get_address());
	}
	
	TcpUplinkClient(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
	}
	
	TcpUplinkClient& operator=(const vnl::Address& addr) {
		vnl::Client::set_address(addr);
		return *this;
	}
	
	void publish(const vnl::Address& addr) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.publish(addr);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void unsubscribe(const vnl::String& domain, const vnl::String& topic) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.unsubscribe(domain, topic);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void subscribe(const vnl::String& domain, const vnl::String& topic) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.subscribe(domain, topic);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void reset() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.reset();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void publish(const vnl::String& domain, const vnl::String& topic) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.publish(domain, topic);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	vnl::info::RemoteInfo get_remote_info() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_remote_info();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		vnl::info::RemoteInfo _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	void unpublish(const vnl::String& domain, const vnl::String& topic) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.unpublish(domain, topic);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_error_interval(int32_t error_interval) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_error_interval(error_interval);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_are_connected(bool are_connected) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_are_connected(are_connected);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_num_read(int64_t num_read) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_num_read(num_read);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_num_write(int64_t num_write) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_num_write(num_write);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_num_flush(int64_t num_flush) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_num_flush(num_flush);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_num_bytes_read(int64_t num_bytes_read) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_num_bytes_read(num_bytes_read);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	void set_num_bytes_write(int64_t num_bytes_write) {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.set_num_bytes_write(num_bytes_write);
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CALL);
		if(_pkt) {
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
	}
	
	int32_t get_error_interval() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_error_interval();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int32_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	bool get_are_connected() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_are_connected();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		bool _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int64_t get_num_read() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_num_read();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int64_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int64_t get_num_write() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_num_write();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int64_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int64_t get_num_flush() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_num_flush();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int64_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int64_t get_num_bytes_read() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_num_bytes_read();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int64_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
	int64_t get_num_bytes_write() {
		_buf.wrap(_data);
		{
			Writer _wr(_out);
			_wr.get_num_bytes_write();
		}
		vnl::Packet* _pkt = _call(vnl::Frame::CONST_CALL);
		int64_t _result;
		if(_pkt) {
			vnl::read(_in, _result);
			_pkt->ack();
		} else {
			throw vnl::IOException();
		}
		return _result;
	}
	
};


} // namespace

#endif // INCLUDE_VNI_GENERATED_vnl_TcpUplink_CLIENT_HXX_
